// This file is generated by rust-protobuf 2.12.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `realtime/data.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_12_0;

#[derive(PartialEq,Clone,Default)]
pub struct PricingData {
    // message fields
    pub id: ::std::string::String,
    pub price: f32,
    pub time: i64,
    pub currency: ::std::string::String,
    pub exchange: ::std::string::String,
    pub quoteType: PricingData_QuoteType,
    pub marketHours: PricingData_MarketHoursType,
    pub changePercent: f32,
    pub dayVolume: i64,
    pub dayHigh: f32,
    pub dayLow: f32,
    pub change: f32,
    pub shortName: ::std::string::String,
    pub expireDate: i64,
    pub openPrice: f32,
    pub previousClose: f32,
    pub strikePrice: f32,
    pub underlyingSymbol: ::std::string::String,
    pub openInterest: i64,
    pub optionsType: PricingData_OptionType,
    pub miniOption: i64,
    pub lastSize: i64,
    pub bid: f32,
    pub bidSize: i64,
    pub ask: f32,
    pub askSize: i64,
    pub priceHint: i64,
    pub vol_24hr: i64,
    pub volAllCurrencies: i64,
    pub fromcurrency: ::std::string::String,
    pub lastMarket: ::std::string::String,
    pub circulatingSupply: f64,
    pub marketcap: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PricingData {
    fn default() -> &'a PricingData {
        <PricingData as ::protobuf::Message>::default_instance()
    }
}

impl PricingData {
    pub fn new() -> PricingData {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // float price = 2;


    pub fn get_price(&self) -> f32 {
        self.price
    }
    pub fn clear_price(&mut self) {
        self.price = 0.;
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: f32) {
        self.price = v;
    }

    // sint64 time = 3;


    pub fn get_time(&self) -> i64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i64) {
        self.time = v;
    }

    // string currency = 4;


    pub fn get_currency(&self) -> &str {
        &self.currency
    }
    pub fn clear_currency(&mut self) {
        self.currency.clear();
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: ::std::string::String) {
        self.currency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currency(&mut self) -> &mut ::std::string::String {
        &mut self.currency
    }

    // Take field
    pub fn take_currency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.currency, ::std::string::String::new())
    }

    // string exchange = 5;


    pub fn get_exchange(&self) -> &str {
        &self.exchange
    }
    pub fn clear_exchange(&mut self) {
        self.exchange.clear();
    }

    // Param is passed by value, moved
    pub fn set_exchange(&mut self, v: ::std::string::String) {
        self.exchange = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exchange(&mut self) -> &mut ::std::string::String {
        &mut self.exchange
    }

    // Take field
    pub fn take_exchange(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exchange, ::std::string::String::new())
    }

    // .PricingData.QuoteType quoteType = 6;


    pub fn get_quoteType(&self) -> PricingData_QuoteType {
        self.quoteType
    }
    pub fn clear_quoteType(&mut self) {
        self.quoteType = PricingData_QuoteType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_quoteType(&mut self, v: PricingData_QuoteType) {
        self.quoteType = v;
    }

    // .PricingData.MarketHoursType marketHours = 7;


    pub fn get_marketHours(&self) -> PricingData_MarketHoursType {
        self.marketHours
    }
    pub fn clear_marketHours(&mut self) {
        self.marketHours = PricingData_MarketHoursType::PRE_MARKET;
    }

    // Param is passed by value, moved
    pub fn set_marketHours(&mut self, v: PricingData_MarketHoursType) {
        self.marketHours = v;
    }

    // float changePercent = 8;


    pub fn get_changePercent(&self) -> f32 {
        self.changePercent
    }
    pub fn clear_changePercent(&mut self) {
        self.changePercent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_changePercent(&mut self, v: f32) {
        self.changePercent = v;
    }

    // sint64 dayVolume = 9;


    pub fn get_dayVolume(&self) -> i64 {
        self.dayVolume
    }
    pub fn clear_dayVolume(&mut self) {
        self.dayVolume = 0;
    }

    // Param is passed by value, moved
    pub fn set_dayVolume(&mut self, v: i64) {
        self.dayVolume = v;
    }

    // float dayHigh = 10;


    pub fn get_dayHigh(&self) -> f32 {
        self.dayHigh
    }
    pub fn clear_dayHigh(&mut self) {
        self.dayHigh = 0.;
    }

    // Param is passed by value, moved
    pub fn set_dayHigh(&mut self, v: f32) {
        self.dayHigh = v;
    }

    // float dayLow = 11;


    pub fn get_dayLow(&self) -> f32 {
        self.dayLow
    }
    pub fn clear_dayLow(&mut self) {
        self.dayLow = 0.;
    }

    // Param is passed by value, moved
    pub fn set_dayLow(&mut self, v: f32) {
        self.dayLow = v;
    }

    // float change = 12;


    pub fn get_change(&self) -> f32 {
        self.change
    }
    pub fn clear_change(&mut self) {
        self.change = 0.;
    }

    // Param is passed by value, moved
    pub fn set_change(&mut self, v: f32) {
        self.change = v;
    }

    // string shortName = 13;


    pub fn get_shortName(&self) -> &str {
        &self.shortName
    }
    pub fn clear_shortName(&mut self) {
        self.shortName.clear();
    }

    // Param is passed by value, moved
    pub fn set_shortName(&mut self, v: ::std::string::String) {
        self.shortName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortName(&mut self) -> &mut ::std::string::String {
        &mut self.shortName
    }

    // Take field
    pub fn take_shortName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.shortName, ::std::string::String::new())
    }

    // sint64 expireDate = 14;


    pub fn get_expireDate(&self) -> i64 {
        self.expireDate
    }
    pub fn clear_expireDate(&mut self) {
        self.expireDate = 0;
    }

    // Param is passed by value, moved
    pub fn set_expireDate(&mut self, v: i64) {
        self.expireDate = v;
    }

    // float openPrice = 15;


    pub fn get_openPrice(&self) -> f32 {
        self.openPrice
    }
    pub fn clear_openPrice(&mut self) {
        self.openPrice = 0.;
    }

    // Param is passed by value, moved
    pub fn set_openPrice(&mut self, v: f32) {
        self.openPrice = v;
    }

    // float previousClose = 16;


    pub fn get_previousClose(&self) -> f32 {
        self.previousClose
    }
    pub fn clear_previousClose(&mut self) {
        self.previousClose = 0.;
    }

    // Param is passed by value, moved
    pub fn set_previousClose(&mut self, v: f32) {
        self.previousClose = v;
    }

    // float strikePrice = 17;


    pub fn get_strikePrice(&self) -> f32 {
        self.strikePrice
    }
    pub fn clear_strikePrice(&mut self) {
        self.strikePrice = 0.;
    }

    // Param is passed by value, moved
    pub fn set_strikePrice(&mut self, v: f32) {
        self.strikePrice = v;
    }

    // string underlyingSymbol = 18;


    pub fn get_underlyingSymbol(&self) -> &str {
        &self.underlyingSymbol
    }
    pub fn clear_underlyingSymbol(&mut self) {
        self.underlyingSymbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_underlyingSymbol(&mut self, v: ::std::string::String) {
        self.underlyingSymbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_underlyingSymbol(&mut self) -> &mut ::std::string::String {
        &mut self.underlyingSymbol
    }

    // Take field
    pub fn take_underlyingSymbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.underlyingSymbol, ::std::string::String::new())
    }

    // sint64 openInterest = 19;


    pub fn get_openInterest(&self) -> i64 {
        self.openInterest
    }
    pub fn clear_openInterest(&mut self) {
        self.openInterest = 0;
    }

    // Param is passed by value, moved
    pub fn set_openInterest(&mut self, v: i64) {
        self.openInterest = v;
    }

    // .PricingData.OptionType optionsType = 20;


    pub fn get_optionsType(&self) -> PricingData_OptionType {
        self.optionsType
    }
    pub fn clear_optionsType(&mut self) {
        self.optionsType = PricingData_OptionType::CALL;
    }

    // Param is passed by value, moved
    pub fn set_optionsType(&mut self, v: PricingData_OptionType) {
        self.optionsType = v;
    }

    // sint64 miniOption = 21;


    pub fn get_miniOption(&self) -> i64 {
        self.miniOption
    }
    pub fn clear_miniOption(&mut self) {
        self.miniOption = 0;
    }

    // Param is passed by value, moved
    pub fn set_miniOption(&mut self, v: i64) {
        self.miniOption = v;
    }

    // sint64 lastSize = 22;


    pub fn get_lastSize(&self) -> i64 {
        self.lastSize
    }
    pub fn clear_lastSize(&mut self) {
        self.lastSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_lastSize(&mut self, v: i64) {
        self.lastSize = v;
    }

    // float bid = 23;


    pub fn get_bid(&self) -> f32 {
        self.bid
    }
    pub fn clear_bid(&mut self) {
        self.bid = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bid(&mut self, v: f32) {
        self.bid = v;
    }

    // sint64 bidSize = 24;


    pub fn get_bidSize(&self) -> i64 {
        self.bidSize
    }
    pub fn clear_bidSize(&mut self) {
        self.bidSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_bidSize(&mut self, v: i64) {
        self.bidSize = v;
    }

    // float ask = 25;


    pub fn get_ask(&self) -> f32 {
        self.ask
    }
    pub fn clear_ask(&mut self) {
        self.ask = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ask(&mut self, v: f32) {
        self.ask = v;
    }

    // sint64 askSize = 26;


    pub fn get_askSize(&self) -> i64 {
        self.askSize
    }
    pub fn clear_askSize(&mut self) {
        self.askSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_askSize(&mut self, v: i64) {
        self.askSize = v;
    }

    // sint64 priceHint = 27;


    pub fn get_priceHint(&self) -> i64 {
        self.priceHint
    }
    pub fn clear_priceHint(&mut self) {
        self.priceHint = 0;
    }

    // Param is passed by value, moved
    pub fn set_priceHint(&mut self, v: i64) {
        self.priceHint = v;
    }

    // sint64 vol_24hr = 28;


    pub fn get_vol_24hr(&self) -> i64 {
        self.vol_24hr
    }
    pub fn clear_vol_24hr(&mut self) {
        self.vol_24hr = 0;
    }

    // Param is passed by value, moved
    pub fn set_vol_24hr(&mut self, v: i64) {
        self.vol_24hr = v;
    }

    // sint64 volAllCurrencies = 29;


    pub fn get_volAllCurrencies(&self) -> i64 {
        self.volAllCurrencies
    }
    pub fn clear_volAllCurrencies(&mut self) {
        self.volAllCurrencies = 0;
    }

    // Param is passed by value, moved
    pub fn set_volAllCurrencies(&mut self, v: i64) {
        self.volAllCurrencies = v;
    }

    // string fromcurrency = 30;


    pub fn get_fromcurrency(&self) -> &str {
        &self.fromcurrency
    }
    pub fn clear_fromcurrency(&mut self) {
        self.fromcurrency.clear();
    }

    // Param is passed by value, moved
    pub fn set_fromcurrency(&mut self, v: ::std::string::String) {
        self.fromcurrency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromcurrency(&mut self) -> &mut ::std::string::String {
        &mut self.fromcurrency
    }

    // Take field
    pub fn take_fromcurrency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fromcurrency, ::std::string::String::new())
    }

    // string lastMarket = 31;


    pub fn get_lastMarket(&self) -> &str {
        &self.lastMarket
    }
    pub fn clear_lastMarket(&mut self) {
        self.lastMarket.clear();
    }

    // Param is passed by value, moved
    pub fn set_lastMarket(&mut self, v: ::std::string::String) {
        self.lastMarket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastMarket(&mut self) -> &mut ::std::string::String {
        &mut self.lastMarket
    }

    // Take field
    pub fn take_lastMarket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lastMarket, ::std::string::String::new())
    }

    // double circulatingSupply = 32;


    pub fn get_circulatingSupply(&self) -> f64 {
        self.circulatingSupply
    }
    pub fn clear_circulatingSupply(&mut self) {
        self.circulatingSupply = 0.;
    }

    // Param is passed by value, moved
    pub fn set_circulatingSupply(&mut self, v: f64) {
        self.circulatingSupply = v;
    }

    // double marketcap = 33;


    pub fn get_marketcap(&self) -> f64 {
        self.marketcap
    }
    pub fn clear_marketcap(&mut self) {
        self.marketcap = 0.;
    }

    // Param is passed by value, moved
    pub fn set_marketcap(&mut self, v: f64) {
        self.marketcap = v;
    }
}

impl ::protobuf::Message for PricingData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.price = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.time = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.currency)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exchange)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.quoteType, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.marketHours, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.changePercent = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.dayVolume = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.dayHigh = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.dayLow = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.change = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.shortName)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.expireDate = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.openPrice = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.previousClose = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.strikePrice = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.underlyingSymbol)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.openInterest = tmp;
                },
                20 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.optionsType, 20, &mut self.unknown_fields)?
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.miniOption = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.lastSize = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bid = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.bidSize = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ask = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.askSize = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.priceHint = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.vol_24hr = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.volAllCurrencies = tmp;
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fromcurrency)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lastMarket)?;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.circulatingSupply = tmp;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.marketcap = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.price != 0. {
            my_size += 5;
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.time);
        }
        if !self.currency.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.currency);
        }
        if !self.exchange.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.exchange);
        }
        if self.quoteType != PricingData_QuoteType::NONE {
            my_size += ::protobuf::rt::enum_size(6, self.quoteType);
        }
        if self.marketHours != PricingData_MarketHoursType::PRE_MARKET {
            my_size += ::protobuf::rt::enum_size(7, self.marketHours);
        }
        if self.changePercent != 0. {
            my_size += 5;
        }
        if self.dayVolume != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(9, self.dayVolume);
        }
        if self.dayHigh != 0. {
            my_size += 5;
        }
        if self.dayLow != 0. {
            my_size += 5;
        }
        if self.change != 0. {
            my_size += 5;
        }
        if !self.shortName.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.shortName);
        }
        if self.expireDate != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(14, self.expireDate);
        }
        if self.openPrice != 0. {
            my_size += 5;
        }
        if self.previousClose != 0. {
            my_size += 6;
        }
        if self.strikePrice != 0. {
            my_size += 6;
        }
        if !self.underlyingSymbol.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.underlyingSymbol);
        }
        if self.openInterest != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(19, self.openInterest);
        }
        if self.optionsType != PricingData_OptionType::CALL {
            my_size += ::protobuf::rt::enum_size(20, self.optionsType);
        }
        if self.miniOption != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(21, self.miniOption);
        }
        if self.lastSize != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(22, self.lastSize);
        }
        if self.bid != 0. {
            my_size += 6;
        }
        if self.bidSize != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(24, self.bidSize);
        }
        if self.ask != 0. {
            my_size += 6;
        }
        if self.askSize != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(26, self.askSize);
        }
        if self.priceHint != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(27, self.priceHint);
        }
        if self.vol_24hr != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(28, self.vol_24hr);
        }
        if self.volAllCurrencies != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(29, self.volAllCurrencies);
        }
        if !self.fromcurrency.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.fromcurrency);
        }
        if !self.lastMarket.is_empty() {
            my_size += ::protobuf::rt::string_size(31, &self.lastMarket);
        }
        if self.circulatingSupply != 0. {
            my_size += 10;
        }
        if self.marketcap != 0. {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.price != 0. {
            os.write_float(2, self.price)?;
        }
        if self.time != 0 {
            os.write_sint64(3, self.time)?;
        }
        if !self.currency.is_empty() {
            os.write_string(4, &self.currency)?;
        }
        if !self.exchange.is_empty() {
            os.write_string(5, &self.exchange)?;
        }
        if self.quoteType != PricingData_QuoteType::NONE {
            os.write_enum(6, self.quoteType.value())?;
        }
        if self.marketHours != PricingData_MarketHoursType::PRE_MARKET {
            os.write_enum(7, self.marketHours.value())?;
        }
        if self.changePercent != 0. {
            os.write_float(8, self.changePercent)?;
        }
        if self.dayVolume != 0 {
            os.write_sint64(9, self.dayVolume)?;
        }
        if self.dayHigh != 0. {
            os.write_float(10, self.dayHigh)?;
        }
        if self.dayLow != 0. {
            os.write_float(11, self.dayLow)?;
        }
        if self.change != 0. {
            os.write_float(12, self.change)?;
        }
        if !self.shortName.is_empty() {
            os.write_string(13, &self.shortName)?;
        }
        if self.expireDate != 0 {
            os.write_sint64(14, self.expireDate)?;
        }
        if self.openPrice != 0. {
            os.write_float(15, self.openPrice)?;
        }
        if self.previousClose != 0. {
            os.write_float(16, self.previousClose)?;
        }
        if self.strikePrice != 0. {
            os.write_float(17, self.strikePrice)?;
        }
        if !self.underlyingSymbol.is_empty() {
            os.write_string(18, &self.underlyingSymbol)?;
        }
        if self.openInterest != 0 {
            os.write_sint64(19, self.openInterest)?;
        }
        if self.optionsType != PricingData_OptionType::CALL {
            os.write_enum(20, self.optionsType.value())?;
        }
        if self.miniOption != 0 {
            os.write_sint64(21, self.miniOption)?;
        }
        if self.lastSize != 0 {
            os.write_sint64(22, self.lastSize)?;
        }
        if self.bid != 0. {
            os.write_float(23, self.bid)?;
        }
        if self.bidSize != 0 {
            os.write_sint64(24, self.bidSize)?;
        }
        if self.ask != 0. {
            os.write_float(25, self.ask)?;
        }
        if self.askSize != 0 {
            os.write_sint64(26, self.askSize)?;
        }
        if self.priceHint != 0 {
            os.write_sint64(27, self.priceHint)?;
        }
        if self.vol_24hr != 0 {
            os.write_sint64(28, self.vol_24hr)?;
        }
        if self.volAllCurrencies != 0 {
            os.write_sint64(29, self.volAllCurrencies)?;
        }
        if !self.fromcurrency.is_empty() {
            os.write_string(30, &self.fromcurrency)?;
        }
        if !self.lastMarket.is_empty() {
            os.write_string(31, &self.lastMarket)?;
        }
        if self.circulatingSupply != 0. {
            os.write_double(32, self.circulatingSupply)?;
        }
        if self.marketcap != 0. {
            os.write_double(33, self.marketcap)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PricingData {
        PricingData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &PricingData| { &m.id },
                    |m: &mut PricingData| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "price",
                    |m: &PricingData| { &m.price },
                    |m: &mut PricingData| { &mut m.price },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "time",
                    |m: &PricingData| { &m.time },
                    |m: &mut PricingData| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "currency",
                    |m: &PricingData| { &m.currency },
                    |m: &mut PricingData| { &mut m.currency },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exchange",
                    |m: &PricingData| { &m.exchange },
                    |m: &mut PricingData| { &mut m.exchange },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PricingData_QuoteType>>(
                    "quoteType",
                    |m: &PricingData| { &m.quoteType },
                    |m: &mut PricingData| { &mut m.quoteType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PricingData_MarketHoursType>>(
                    "marketHours",
                    |m: &PricingData| { &m.marketHours },
                    |m: &mut PricingData| { &mut m.marketHours },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "changePercent",
                    |m: &PricingData| { &m.changePercent },
                    |m: &mut PricingData| { &mut m.changePercent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "dayVolume",
                    |m: &PricingData| { &m.dayVolume },
                    |m: &mut PricingData| { &mut m.dayVolume },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "dayHigh",
                    |m: &PricingData| { &m.dayHigh },
                    |m: &mut PricingData| { &mut m.dayHigh },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "dayLow",
                    |m: &PricingData| { &m.dayLow },
                    |m: &mut PricingData| { &mut m.dayLow },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "change",
                    |m: &PricingData| { &m.change },
                    |m: &mut PricingData| { &mut m.change },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "shortName",
                    |m: &PricingData| { &m.shortName },
                    |m: &mut PricingData| { &mut m.shortName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "expireDate",
                    |m: &PricingData| { &m.expireDate },
                    |m: &mut PricingData| { &mut m.expireDate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "openPrice",
                    |m: &PricingData| { &m.openPrice },
                    |m: &mut PricingData| { &mut m.openPrice },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "previousClose",
                    |m: &PricingData| { &m.previousClose },
                    |m: &mut PricingData| { &mut m.previousClose },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "strikePrice",
                    |m: &PricingData| { &m.strikePrice },
                    |m: &mut PricingData| { &mut m.strikePrice },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "underlyingSymbol",
                    |m: &PricingData| { &m.underlyingSymbol },
                    |m: &mut PricingData| { &mut m.underlyingSymbol },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "openInterest",
                    |m: &PricingData| { &m.openInterest },
                    |m: &mut PricingData| { &mut m.openInterest },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PricingData_OptionType>>(
                    "optionsType",
                    |m: &PricingData| { &m.optionsType },
                    |m: &mut PricingData| { &mut m.optionsType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "miniOption",
                    |m: &PricingData| { &m.miniOption },
                    |m: &mut PricingData| { &mut m.miniOption },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "lastSize",
                    |m: &PricingData| { &m.lastSize },
                    |m: &mut PricingData| { &mut m.lastSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "bid",
                    |m: &PricingData| { &m.bid },
                    |m: &mut PricingData| { &mut m.bid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "bidSize",
                    |m: &PricingData| { &m.bidSize },
                    |m: &mut PricingData| { &mut m.bidSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "ask",
                    |m: &PricingData| { &m.ask },
                    |m: &mut PricingData| { &mut m.ask },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "askSize",
                    |m: &PricingData| { &m.askSize },
                    |m: &mut PricingData| { &mut m.askSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "priceHint",
                    |m: &PricingData| { &m.priceHint },
                    |m: &mut PricingData| { &mut m.priceHint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "vol_24hr",
                    |m: &PricingData| { &m.vol_24hr },
                    |m: &mut PricingData| { &mut m.vol_24hr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "volAllCurrencies",
                    |m: &PricingData| { &m.volAllCurrencies },
                    |m: &mut PricingData| { &mut m.volAllCurrencies },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fromcurrency",
                    |m: &PricingData| { &m.fromcurrency },
                    |m: &mut PricingData| { &mut m.fromcurrency },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lastMarket",
                    |m: &PricingData| { &m.lastMarket },
                    |m: &mut PricingData| { &mut m.lastMarket },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "circulatingSupply",
                    |m: &PricingData| { &m.circulatingSupply },
                    |m: &mut PricingData| { &mut m.circulatingSupply },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "marketcap",
                    |m: &PricingData| { &m.marketcap },
                    |m: &mut PricingData| { &mut m.marketcap },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PricingData>(
                    "PricingData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PricingData {
        static mut instance: ::protobuf::lazy::Lazy<PricingData> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PricingData::new)
        }
    }
}

impl ::protobuf::Clear for PricingData {
    fn clear(&mut self) {
        self.id.clear();
        self.price = 0.;
        self.time = 0;
        self.currency.clear();
        self.exchange.clear();
        self.quoteType = PricingData_QuoteType::NONE;
        self.marketHours = PricingData_MarketHoursType::PRE_MARKET;
        self.changePercent = 0.;
        self.dayVolume = 0;
        self.dayHigh = 0.;
        self.dayLow = 0.;
        self.change = 0.;
        self.shortName.clear();
        self.expireDate = 0;
        self.openPrice = 0.;
        self.previousClose = 0.;
        self.strikePrice = 0.;
        self.underlyingSymbol.clear();
        self.openInterest = 0;
        self.optionsType = PricingData_OptionType::CALL;
        self.miniOption = 0;
        self.lastSize = 0;
        self.bid = 0.;
        self.bidSize = 0;
        self.ask = 0.;
        self.askSize = 0;
        self.priceHint = 0;
        self.vol_24hr = 0;
        self.volAllCurrencies = 0;
        self.fromcurrency.clear();
        self.lastMarket.clear();
        self.circulatingSupply = 0.;
        self.marketcap = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PricingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PricingData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PricingData_QuoteType {
    NONE = 0,
    ALTSYMBOL = 5,
    HEARTBEAT = 7,
    EQUITY = 8,
    INDEX = 9,
    MUTUALFUND = 11,
    MONEYMARKET = 12,
    OPTION = 13,
    CURRENCY = 14,
    WARRANT = 15,
    BOND = 17,
    FUTURE = 18,
    ETF = 20,
    COMMODITY = 23,
    ECNQUOTE = 28,
    CRYPTOCURRENCY = 41,
    INDICATOR = 42,
    INDUSTRY = 1000,
}

impl ::protobuf::ProtobufEnum for PricingData_QuoteType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PricingData_QuoteType> {
        match value {
            0 => ::std::option::Option::Some(PricingData_QuoteType::NONE),
            5 => ::std::option::Option::Some(PricingData_QuoteType::ALTSYMBOL),
            7 => ::std::option::Option::Some(PricingData_QuoteType::HEARTBEAT),
            8 => ::std::option::Option::Some(PricingData_QuoteType::EQUITY),
            9 => ::std::option::Option::Some(PricingData_QuoteType::INDEX),
            11 => ::std::option::Option::Some(PricingData_QuoteType::MUTUALFUND),
            12 => ::std::option::Option::Some(PricingData_QuoteType::MONEYMARKET),
            13 => ::std::option::Option::Some(PricingData_QuoteType::OPTION),
            14 => ::std::option::Option::Some(PricingData_QuoteType::CURRENCY),
            15 => ::std::option::Option::Some(PricingData_QuoteType::WARRANT),
            17 => ::std::option::Option::Some(PricingData_QuoteType::BOND),
            18 => ::std::option::Option::Some(PricingData_QuoteType::FUTURE),
            20 => ::std::option::Option::Some(PricingData_QuoteType::ETF),
            23 => ::std::option::Option::Some(PricingData_QuoteType::COMMODITY),
            28 => ::std::option::Option::Some(PricingData_QuoteType::ECNQUOTE),
            41 => ::std::option::Option::Some(PricingData_QuoteType::CRYPTOCURRENCY),
            42 => ::std::option::Option::Some(PricingData_QuoteType::INDICATOR),
            1000 => ::std::option::Option::Some(PricingData_QuoteType::INDUSTRY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PricingData_QuoteType] = &[
            PricingData_QuoteType::NONE,
            PricingData_QuoteType::ALTSYMBOL,
            PricingData_QuoteType::HEARTBEAT,
            PricingData_QuoteType::EQUITY,
            PricingData_QuoteType::INDEX,
            PricingData_QuoteType::MUTUALFUND,
            PricingData_QuoteType::MONEYMARKET,
            PricingData_QuoteType::OPTION,
            PricingData_QuoteType::CURRENCY,
            PricingData_QuoteType::WARRANT,
            PricingData_QuoteType::BOND,
            PricingData_QuoteType::FUTURE,
            PricingData_QuoteType::ETF,
            PricingData_QuoteType::COMMODITY,
            PricingData_QuoteType::ECNQUOTE,
            PricingData_QuoteType::CRYPTOCURRENCY,
            PricingData_QuoteType::INDICATOR,
            PricingData_QuoteType::INDUSTRY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<PricingData_QuoteType>("PricingData.QuoteType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PricingData_QuoteType {
}

impl ::std::default::Default for PricingData_QuoteType {
    fn default() -> Self {
        PricingData_QuoteType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for PricingData_QuoteType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PricingData_OptionType {
    CALL = 0,
    PUT = 1,
}

impl ::protobuf::ProtobufEnum for PricingData_OptionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PricingData_OptionType> {
        match value {
            0 => ::std::option::Option::Some(PricingData_OptionType::CALL),
            1 => ::std::option::Option::Some(PricingData_OptionType::PUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PricingData_OptionType] = &[
            PricingData_OptionType::CALL,
            PricingData_OptionType::PUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<PricingData_OptionType>("PricingData.OptionType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PricingData_OptionType {
}

impl ::std::default::Default for PricingData_OptionType {
    fn default() -> Self {
        PricingData_OptionType::CALL
    }
}

impl ::protobuf::reflect::ProtobufValue for PricingData_OptionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PricingData_MarketHoursType {
    PRE_MARKET = 0,
    REGULAR_MARKET = 1,
    POST_MARKET = 2,
    EXTENDED_HOURS_MARKET = 3,
}

impl ::protobuf::ProtobufEnum for PricingData_MarketHoursType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PricingData_MarketHoursType> {
        match value {
            0 => ::std::option::Option::Some(PricingData_MarketHoursType::PRE_MARKET),
            1 => ::std::option::Option::Some(PricingData_MarketHoursType::REGULAR_MARKET),
            2 => ::std::option::Option::Some(PricingData_MarketHoursType::POST_MARKET),
            3 => ::std::option::Option::Some(PricingData_MarketHoursType::EXTENDED_HOURS_MARKET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PricingData_MarketHoursType] = &[
            PricingData_MarketHoursType::PRE_MARKET,
            PricingData_MarketHoursType::REGULAR_MARKET,
            PricingData_MarketHoursType::POST_MARKET,
            PricingData_MarketHoursType::EXTENDED_HOURS_MARKET,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<PricingData_MarketHoursType>("PricingData.MarketHoursType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PricingData_MarketHoursType {
}

impl ::std::default::Default for PricingData_MarketHoursType {
    fn default() -> Self {
        PricingData_MarketHoursType::PRE_MARKET
    }
}

impl ::protobuf::reflect::ProtobufValue for PricingData_MarketHoursType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13realtime/data.proto\"\xc2\x0b\n\x0bPricingData\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x14\n\x05price\x18\x02\x20\x01(\x02R\x05price\
    \x12\x12\n\x04time\x18\x03\x20\x01(\x12R\x04time\x12\x1a\n\x08currency\
    \x18\x04\x20\x01(\tR\x08currency\x12\x1a\n\x08exchange\x18\x05\x20\x01(\
    \tR\x08exchange\x124\n\tquoteType\x18\x06\x20\x01(\x0e2\x16.PricingData.\
    QuoteTypeR\tquoteType\x12>\n\x0bmarketHours\x18\x07\x20\x01(\x0e2\x1c.Pr\
    icingData.MarketHoursTypeR\x0bmarketHours\x12$\n\rchangePercent\x18\x08\
    \x20\x01(\x02R\rchangePercent\x12\x1c\n\tdayVolume\x18\t\x20\x01(\x12R\t\
    dayVolume\x12\x18\n\x07dayHigh\x18\n\x20\x01(\x02R\x07dayHigh\x12\x16\n\
    \x06dayLow\x18\x0b\x20\x01(\x02R\x06dayLow\x12\x16\n\x06change\x18\x0c\
    \x20\x01(\x02R\x06change\x12\x1c\n\tshortName\x18\r\x20\x01(\tR\tshortNa\
    me\x12\x1e\n\nexpireDate\x18\x0e\x20\x01(\x12R\nexpireDate\x12\x1c\n\top\
    enPrice\x18\x0f\x20\x01(\x02R\topenPrice\x12$\n\rpreviousClose\x18\x10\
    \x20\x01(\x02R\rpreviousClose\x12\x20\n\x0bstrikePrice\x18\x11\x20\x01(\
    \x02R\x0bstrikePrice\x12*\n\x10underlyingSymbol\x18\x12\x20\x01(\tR\x10u\
    nderlyingSymbol\x12\"\n\x0copenInterest\x18\x13\x20\x01(\x12R\x0copenInt\
    erest\x129\n\x0boptionsType\x18\x14\x20\x01(\x0e2\x17.PricingData.Option\
    TypeR\x0boptionsType\x12\x1e\n\nminiOption\x18\x15\x20\x01(\x12R\nminiOp\
    tion\x12\x1a\n\x08lastSize\x18\x16\x20\x01(\x12R\x08lastSize\x12\x10\n\
    \x03bid\x18\x17\x20\x01(\x02R\x03bid\x12\x18\n\x07bidSize\x18\x18\x20\
    \x01(\x12R\x07bidSize\x12\x10\n\x03ask\x18\x19\x20\x01(\x02R\x03ask\x12\
    \x18\n\x07askSize\x18\x1a\x20\x01(\x12R\x07askSize\x12\x1c\n\tpriceHint\
    \x18\x1b\x20\x01(\x12R\tpriceHint\x12\x19\n\x08vol_24hr\x18\x1c\x20\x01(\
    \x12R\x07vol24hr\x12*\n\x10volAllCurrencies\x18\x1d\x20\x01(\x12R\x10vol\
    AllCurrencies\x12\"\n\x0cfromcurrency\x18\x1e\x20\x01(\tR\x0cfromcurrenc\
    y\x12\x1e\n\nlastMarket\x18\x1f\x20\x01(\tR\nlastMarket\x12,\n\x11circul\
    atingSupply\x18\x20\x20\x01(\x01R\x11circulatingSupply\x12\x1c\n\tmarket\
    cap\x18!\x20\x01(\x01R\tmarketcap\"\x80\x02\n\tQuoteType\x12\x08\n\x04NO\
    NE\x10\0\x12\r\n\tALTSYMBOL\x10\x05\x12\r\n\tHEARTBEAT\x10\x07\x12\n\n\
    \x06EQUITY\x10\x08\x12\t\n\x05INDEX\x10\t\x12\x0e\n\nMUTUALFUND\x10\x0b\
    \x12\x0f\n\x0bMONEYMARKET\x10\x0c\x12\n\n\x06OPTION\x10\r\x12\x0c\n\x08C\
    URRENCY\x10\x0e\x12\x0b\n\x07WARRANT\x10\x0f\x12\x08\n\x04BOND\x10\x11\
    \x12\n\n\x06FUTURE\x10\x12\x12\x07\n\x03ETF\x10\x14\x12\r\n\tCOMMODITY\
    \x10\x17\x12\x0c\n\x08ECNQUOTE\x10\x1c\x12\x12\n\x0eCRYPTOCURRENCY\x10)\
    \x12\r\n\tINDICATOR\x10*\x12\r\n\x08INDUSTRY\x10\xe8\x07\"\x1f\n\nOption\
    Type\x12\x08\n\x04CALL\x10\0\x12\x07\n\x03PUT\x10\x01\"a\n\x0fMarketHour\
    sType\x12\x0e\n\nPRE_MARKET\x10\0\x12\x12\n\x0eREGULAR_MARKET\x10\x01\
    \x12\x0f\n\x0bPOST_MARKET\x10\x02\x12\x19\n\x15EXTENDED_HOURS_MARKET\x10\
    \x03b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
